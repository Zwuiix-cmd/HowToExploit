import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import axios from 'axios';

// Define the URL to the proto.yml file
const PROTO_URL = 'https://raw.githubusercontent.com/PrismarineJS/minecraft-data/1b05f407fd82206ce190ff6f8cbccc2fe17247b1/data/bedrock/latest/proto.yml';

// Define the output directory
const OUTPUT_DIR = path.resolve(__dirname, 'src/handler/list');

// Ensure the output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Define types for the proto.yml structure
interface PacketField {
    type?: string;
    [key: string]: any; // Allow additional properties with any type
}

interface PacketInfo {
    fields: Record<string, PacketField>;
}

interface ProtoData {
    packets: Record<string, PacketInfo>;
}

// Fetch and parse the YAML file
async function fetchProtoYml(): Promise<ProtoData> {
    try {
        const response = await axios.get(PROTO_URL);
        // Use a custom YAML loader that ignores tags
        return yaml.load(response.data, { schema: yaml.DEFAULT_SCHEMA }) as ProtoData;
    } catch (error) {
        console.error('Error fetching or parsing proto.yml:', error);
        process.exit(1);
    }
}

// Convert YAML field types to TypeScript types
function yamlTypeToTsType(yamlType: string): string {
    switch (yamlType) {
        case 'u8':
            return 'number'; // uint8 is represented as number in TypeScript
        case 'bool':
            return 'boolean';
        case 'string':
            return 'string';
        case 'string[]varint':
            return 'string[]'; // Adjust as needed for varint arrays
        default:
            return 'any'; // Default case if type is unknown
    }
}

// Generate TypeScript class for a packet
function generatePacketClass(packetName: string, packetFields: Record<string, PacketField>) {
    let fields = '';
    for (const [fieldName, fieldType] of Object.entries(packetFields)) {
        if (typeof fieldType === 'object' && fieldType !== null) {
            // Handle nested fields and conditional fields
            if (fieldType['type']) {
                fields += `  ${fieldName}!: ${yamlTypeToTsType(fieldType['type'])};\n`;
            } else {
                fields += `  ${fieldName}!: {\n`;
                for (const [subFieldName, subFieldType] of Object.entries(fieldType)) {
                    fields += `    ${subFieldName}!: ${yamlTypeToTsType(subFieldType)};\n`;
                }
                fields += `  };\n`;
            }
        } else {
            fields += `  ${fieldName}!: ${yamlTypeToTsType(fieldType as string)};\n`;
        }
    }

    return `export class ${packetName.charAt(0).toUpperCase() + packetName.slice(1)} extends BedrockPacket {
${fields}

  constructor() {
    super("${packetName.charAt(0).toUpperCase() + packetName.slice(1)}", PacketIds.${packetName.toUpperCase()});
  }
}
`;
}

// Main function to generate all packet classes
async function generatePackets() {
    const protoData = await fetchProtoYml();
    const packets = protoData.packets;

    for (const [packetName, packetInfo] of Object.entries(packets)) {
        const packetFields = packetInfo.fields || {};
        const classContent = generatePacketClass(packetName, packetFields);

        fs.writeFileSync(path.join(OUTPUT_DIR, `${packetName}.ts`), classContent, 'utf8');
        console.log(`Generated ${packetName}.ts`);
    }
}

// Run the script
generatePackets().catch(error => {
    console.error('Error generating list:', error);
    process.exit(1);
});
